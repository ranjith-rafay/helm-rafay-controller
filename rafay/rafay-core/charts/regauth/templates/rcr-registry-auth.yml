---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: regauth
  name: regauth
spec:
  ports:
  - name: tcp-regauth
    port: 5001
    protocol: TCP
    targetPort: 5001
  selector:
    app: regauth
  type: ClusterIP

---

apiVersion: v1
data:
  auth_config.yml: |-
    server:  # Server settings.
      # Address to listen on.
      addr: ":5001"

      # URL path prefix to use.
      path_prefix: ""

      # TLS options.
      #
      # Use specific certificate and key.
      certificate: "/certs/tls.crt"
      key: "/certs/tls.key"

    token:  # Settings for the tokens.
      issuer: "Auth Service"  # Must match issuer in the Registry config.
      expiration: 900
      # Token must be signed by a certificate that registry trusts, i.e. by a certificate to which a trust chain
      # can be constructed from one of the certificates in registry's auth.token.rootcertbundle.
      # If not specified, server's TLS certificate and key are used.
      # certificate: "..."
      # key: "..."

    # Authentication methods. All are tried, any one returning success is sufficient.
    # At least one must be configured. If you want an unauthenticated public setup,
    # configure static user map with anonymous access.

    # Static user map.
    users:
    # # Password is specified as a BCrypt hash. Use `htpasswd -nB USERNAME` to generate.
      "rcruser":
       password: {{ .Values.global.secrets.rcruser_secret }}  #
      "rafaycommunityuser":
       password: {{ .Values.global.secrets.rcruser_secret }}  #


    # External authentication - call an external progam to authenticate user.
    # Username and password are passed to command's stdin and exit code is examined.
    # 0 - allow, 1 - deny, 2 - no match, other - error.
    # In case of success, if any output is returned, it is parsed as a JSON object.
    # The "labels" key may contain labels to be passed down to authz, where they can
    # be used in matching. See ext_auth.sh for an example.
    ext_auth:
      command: "/registry-auth"  # Can be a relative path too; $PATH works.
    #  args: ["--flag", "--more", "--flags"]

    # Authorization methods. All are tried, any one returning success is sufficient.
    # At least one must be configured.

    # ACL specifies who can do what. If the match section of an entry matches the
    # request, the set of allowed actions will be applied to the token request
    # and a ticket will be issued only for those of the requested actions that are
    # allowed by the rule.
    #  * It is possible to match on user's name ("account"), subject type ("type")
    #    and name ("name"; for type=repository this is the image name).
    #  * Matches are evaluated as shell file name patterns ("globs") by default,
    #    so "foobar", "f??bar", "f*bar" are all valid. For even more flexibility
    #    match patterns can be evaluated as regexes by enclosing them in //, e.g.
    #    "/(foo|bar)/".
    #  * IP match can be single IP address or a subnet in the "prefix/mask" notation.
    #  * ACL is evaluated in the order it is defined until a match is found.
    #    Rules below the first match are not evaluated, so you'll need to put more
    #    specific rules above more broad ones.
    #  * Empty match clause matches anything, it only makes sense at the end of the
    #    list and can be used as a way of specifying default permissions.
    #  * Empty actions set means "deny everything". Thus, a rule with `actions: []`
    #    is in effect a "deny" rule.
    #  * A special set consisting of a single "*" action means "allow everything".
    #  * If no match is found the default is to deny the request.
    #
    # You can use the following variables from the ticket request in any field:
    #  * ${account} - the account name, currently the same as authenticated user's name.
    #  * ${service} - the service name, specified by auth.token.service in the registry config.
    #  * ${type} - the type of the entity, normally "repository".
    #  * ${name} - the name of the repository (i.e. image), e.g. centos.
    #  * ${labels:<LABEL>} - tests all values in the list of lables:<LABEL> for the user. Refer to the labels doc for details
    acl:
      - match: {name: "rafay-platform/*"}
        actions: ["pull"]
        comment: "Users can pull from rafay-platform tree"
      - match: {name: "${labels:org}/${labels:trees}/*"}
        actions: ["*"]
        comment: "Users have full access to trees assigned to them in their org namespace"
      - match: {account: "rcruser"}
        actions: ["*"]
        comment: "rcruser has full pull access to everything."
      - match: {account: "rafaycommunityuser"}
        actions: ["*"]
        comment: "rafaycommunityuser has full access to rafay-community tree"
      - match: {account: "rcruser", type: "registry", name: "catalog"}
        actions: ["*"]
        comment: "rcruser can do operations on catalog"
kind: ConfigMap
metadata:
  labels:
    name: regauthconf
  name: regauthconf

---

apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: regauth
  name: regauth
spec:
{{- if eq .Values.global.ha_enabled true }}
  replicas: {{ default "3" .Values.global.minReplicaCount }}
{{- else }}
  replicas: {{ default "1" .Values.global.minReplicaCount }}
{{- end }}
  selector:
    matchLabels:
      app: regauth
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: regauth
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                  - key: app
                    operator: In
                    values:
                      - regauth
              topologyKey: kubernetes.io/hostname
      containers:
      - args:
        - -v=2
        - -logtostderr
        - /config/auth_config.yml
        env:
        - name: AUTHSRV_SERVER
          value: authsrv
        - name: AUTHSRV_PORT
          value: "50011"
        image: {{ .Values.registry_auth_image }}
        imagePullPolicy: IfNotPresent
        name: docker-auth
        {{- if or (eq .Values.global.ha_enabled true) (eq .Values.global.size "S") (eq .Values.global.size "M") (eq .Values.global.size "L") }}
        resources:
          limits:
            cpu: "{{ .Values.cpu_limits }}"
            memory: "{{ .Values.memory_limits }}"
          requests:
            cpu: "{{ .Values.cpu_requests }}"
            memory: "{{ .Values.memory_requests }}"
        {{- end }} 
        ports:
        - containerPort: 5001
          name: reg-auth
          protocol: TCP
        volumeMounts:
        - mountPath: /config
          name: config-volume
        - mountPath: /certs
          name: cert-dir
      dnsPolicy: ClusterFirst
      volumes:
      - configMap:
          name: regauthconf
        name: config-volume
      - name: cert-dir
        secret:
{{- if eq .Values.global.generate_self_signed_cert false }}
          secretName: rafay-container-registry-tls-secret-opaque
{{- else }}
          secretName: selfsigned-cert-tls-regauth
{{- end }}
---
{{- if .Values.global.ha_enabled }}
{{- if ne .Values.global.size "S" }}
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  labels:
    app: regauth
  name: regauth
spec:
  maxReplicas: {{ default "10" .Values.maxReplicas }}
{{- if eq .Values.global.ha_enabled true }}
  minReplicas: {{ default "3" .Values.global.minReplicaCount }}
{{- else }}
  minReplicas: {{ default "1" .Values.global.minReplicaCount }}
{{- end }}
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: regauth
  targetCPUUtilizationPercentage: 80
{{- end }}
{{- end }}
